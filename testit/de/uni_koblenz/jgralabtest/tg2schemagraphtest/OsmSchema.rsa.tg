Schema de.uni_koblenz.jgstreetmap.osmschema.OsmSchema;
GraphClass OsmGraph;
 
Package ;
 
Package map;
VertexClass Node: OsmPrimitive { longitude: Double, latitude: Double } ["In each Node, |latitude| must be <= 90.0\u00b0 and  |longitude| must be <= 180.0\u00b0"  "forall n: V{map.Node0} @ abs(n.latitude) <= 90.0 and abs(n.longitude) <= 180.0"  "from n: V{Node} with abs(n.latitude)>90.0 or n.longitude>180.0 report n end"];
abstract VertexClass OsmPrimitive { osmId: Long, tags: Map<String,String>, timeStamp: Long, user: String };
VertexClass Way: OsmPrimitive { closed: Boolean, wayType: routing.SegmentType };
VertexClass Area: Way;
VertexClass Relation: OsmPrimitive;
AggregationClass HasNode from Way (0, *) role way to Node (1, *) role node aggregate from;
AggregationClass HasMember from Relation (0, *) role relation to OsmPrimitive (0, *) role member aggregate from { memberType: String, memberRole: String };
 
Package routing;
EnumDomain SegmentType (NOWAY, CYCLEWAY, MOTORWAY, PRIMARY, SECONDARY, TERTIARY, RESIDENTIAL, FOOTWAY, UNSURFACED, SERVICE, WORMHOLE);
EdgeClass Segment from map.Node (0, *) to map.Node (0, *) { oneway: Boolean, wayType: SegmentType, length: Double, wayId: Long };
 
Package kdtree;
VertexClass KDTree { levels: Integer } ["Each OSM Graph must contain exactly one KDTree vertex."  "exists! t: V{kdtree.KDTree] @ true"  ] ["KDTree must have at least one  level."  "forall t: V{kdtree.KDTree} @ t.levels>=1"  "from t: V{KDTree} with t.levels<1 report t end"];
abstract VertexClass Key { keyValue: Double };
VertexClass NodeSet;
VertexClass XKey: Key ["Each XKey is either an inner node with 2 children or a leaf with a NodeSet."  "forall k: V{kdtree.XKey} @ degree{kdtree.HasYChild}(v) = 2 xor degree{kdtree.HasNodeSet}(v) = 1"  ];
VertexClass YKey: Key ["Each YKey is either an inner node with 2 childred or a leaf with a NodeSet."  "forall k: V{kdtree.YKey} @ degree{kdtree.HasXChild}(v) = 2 xor degree{kdtree.HasNodeSet}(v) = 1"  ];
EdgeClass HasNodeSet from Key (1, 1) role key to NodeSet (0, 1) role set;
AggregationClass HasElement from NodeSet (0, 1) role set to map.Node (1, *) role element aggregate from;
AggregationClass HasRoot from KDTree (0, 1) role tree to Key (1, 1) role root aggregate from;
AggregationClass HasXChild from YKey (0, 1) role parent to XKey (0, 2) role child aggregate from;
AggregationClass HasYChild from XKey (0, 1) role parent to YKey (0, 2) role child aggregate from;

Schema de.uni_koblenz.jgralab.grumlschema.GrumlSchema;

GraphClass SchemaGraph 
  ["The GraphClass may not be abstract."
  "forall gc: V{structure.GraphClass} @ not gc.isAbstract"
  "from gc: V{structure.GraphClass} with gc.isAbstract reportSet gc end"]
  ["There must be exactly one GraphClass."
  "count(V{structure.GraphClass}) = 1"
  "V{structure.GraphClass}"];

Package structure;
VertexClass Schema {name: String, packagePrefix: String};
abstract VertexClass AttributedElementClass {isAbstract: Boolean, qualifiedName: String};
VertexClass AggregationClass: EdgeClass {aggregateFrom: Boolean};
VertexClass Attribute {name: String};
VertexClass CompositionClass: AggregationClass;
VertexClass Constraint {message: String, offendingElementsQuery: String, predicateQuery: String};
VertexClass EdgeClass: GraphElementClass;
VertexClass GraphClass: AttributedElementClass;
abstract VertexClass GraphElementClass: AttributedElementClass;
VertexClass Package {qualifiedName: String} ["A Package must either be default or subpackage, but not both" "forall p: V{structure.Package} @ inDegree{structure.ContainsDefaultPackage}(p) + inDegree{structure.ContainsSubPackage}(p) = 1"];
VertexClass VertexClass: GraphElementClass;

EdgeClass HasDomain from Attribute (0,*) to domains.Domain (1,1);
CompositionClass HasAttribute from AttributedElementClass (1,1) to Attribute (0,*) aggregate from;
CompositionClass HasConstraint from AttributedElementClass (1,1)  to Constraint (0,*) aggregate from;
EdgeClass SpecializesEdgeClass from EdgeClass (0,*) to EdgeClass (0,*);
AggregationClass To from EdgeClass (0,*) to VertexClass (1,1) aggregate from {max: Integer, min: Integer, redefinedRoles: Set<String>, roleName: String};
AggregationClass From from EdgeClass (0,*) to VertexClass (1,1) aggregate from {max: Integer, min: Integer, redefinedRoles: Set<String>, roleName: String};
CompositionClass DefinesGraphClass from Schema (1,1) to GraphClass (1,1) aggregate from;
CompositionClass ContainsGraphElementClass from Package (1,1) to GraphElementClass (0,*) aggregate from;
CompositionClass ContainsSubPackage from Package (0,1) to Package (0,*) aggregate from;
CompositionClass ContainsDefaultPackage from Schema (0,1) to Package (1,1) aggregate from;
EdgeClass SpecializesVertexClass from VertexClass (0,*) to VertexClass (0,*);
CompositionClass ContainsDomain from Package (1,1) to domains.Domain (0,*) aggregate from;

Package domains;
abstract VertexClass Domain {qualifiedName: String};
abstract VertexClass CompositeDomain: Domain;
VertexClass EnumDomain: Domain {enumConstants: List<String>};
VertexClass DoubleDomain: Domain;
VertexClass IntegerDomain: Domain;
VertexClass ListDomain: CollectionDomain;
VertexClass LongDomain: Domain;
VertexClass MapDomain: Domain
  ["The key domain of a MapDomain must not be a collection, record, or map"
  "forall m: V{domains.MapDomain} @ (forall d: m -->{domains.HasKeyDomain} @ not hasType{domains.CollectionDomain, domains.RecordDomain, domains.MapDomain}(d))"];
VertexClass BooleanDomain: Domain;
abstract VertexClass CollectionDomain: Domain;
VertexClass SetDomain: CollectionDomain;
VertexClass StringDomain: Domain;
VertexClass RecordDomain: Domain;

EdgeClass HasBaseDomain from CollectionDomain (0,*) to Domain (1,1);
AggregationClass HasRecordDomainComponent from RecordDomain (0,*) to Domain (1,*) aggregate from {name: String};
EdgeClass HasKeyDomain from MapDomain (0,*) to Domain (1,1);
EdgeClass HasValueDomain from MapDomain (0,*) to Domain (1,1);
